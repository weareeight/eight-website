<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>We Make Software</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #08080A; cursor: pointer; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="glitchCanvas"></canvas>

    <script>
        const canvas = document.getElementById('glitchCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let dots = [];

        // --- CLICK-DRIVEN GLITCH LEVEL ---
        let glitchLevel = 0;
        const maxGlitchLevel = 7; // The chaos caps out at this level

        // --- BASE SETTINGS (for Glitch Level 1) ---
        const config = {
            dotRadius: 12,
            dotColor: '#EAEAEA',
            dotSpacingX: 50,
            dotSpacingY: 50,
            textContent: "we make software",
            textFont: '24px "Courier New", Courier, monospace',
            textColor: '#EAEAEA',
            glitchColor1: 'rgba(0, 255, 255, 0.8)',
            glitchColor2: 'rgba(255, 0, 255, 0.8)',
            backgroundAlpha: 0.6,
            
            // Base values for glitch effects. These will be multiplied by the glitchLevel.
            base: {
                dotGlitchChance: 0.1,
                dotGlitchIntensity: 5,
                textGlitchChance: 0.1,
                textGlitchIntensity: 2,
                scanlineChance: 0.05,
                scanlineIntensity: 10,
                blockScrambleChance: 0.05,
                blockScrambleCount: 2,
                vJumpChance: 0.03,
                vJumpIntensity: 2,
                colorFlashChance: 0.01,
                // --- THIS LINE HAS BEEN CHANGED ---
                flashColor: 'rgba(0, 255, 0, 0.5)', // Was 'rgba(255, 255, 255, 0.5)'
                // Flash frequency limiter (max 3 per second at 60fps = 0.05 chance per frame)
                maxFlashChance: 0.05
            }
        };

        class Dot {
            constructor(baseX, baseY) { this.baseX = baseX; this.baseY = baseY; this.x = baseX; this.y = baseY; this.radius = config.dotRadius; }
            draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = config.dotColor; ctx.fill(); }
            glitch(level) {
                if (Math.random() < config.base.dotGlitchChance * level) {
                    const intensity = config.base.dotGlitchIntensity * level;
                    this.x = this.baseX + (Math.random() - 0.5) * intensity;
                    this.y = this.baseY + (Math.random() - 0.5) * intensity;
                } else { this.x = this.baseX; this.y = this.baseY; }
                if (Math.random() < (config.base.dotGlitchChance / 2) * level) { this.drawAberration(config.glitchColor1, -4); this.drawAberration(config.glitchColor2, 4); }
            }
            drawAberration(color, offset) { ctx.beginPath(); ctx.arc(this.x + (Math.random() - 0.5) * offset, this.y + (Math.random() - 0.5) * offset, this.radius, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); }
            reset() { this.x = this.baseX; this.y = this.baseY; }
        }

        function setup() {
            width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight;
            dots = [];
            const centerX = width / 2; const centerY = height / 2;
            const startX = centerX - config.dotSpacingX; const startY = centerY - config.dotSpacingY - 30;
            for (let i = 0; i < 3; i++) { dots.push(new Dot(startX + i * config.dotSpacingX, startY)); }
            for (let i = 0; i < 3; i++) { dots.push(new Dot(startX + i * config.dotSpacingX, startY + config.dotSpacingY)); }
            for (let i = 0; i < 2; i++) { dots.push(new Dot(startX + i * config.dotSpacingX, startY + 2 * config.dotSpacingY)); }
        }

        function drawText(level) {
            ctx.font = config.textFont; ctx.textAlign = 'center';
            const textX = width / 2; const textY = height / 2 + config.dotSpacingY * 2 + 50;
            if (level > 0 && Math.random() < config.base.textGlitchChance * level) {
                const intensity = config.base.textGlitchIntensity * level;
                const xOffset1 = (Math.random() - 0.5) * intensity; const yOffset1 = (Math.random() - 0.5) * intensity; ctx.fillStyle = config.glitchColor1; ctx.fillText(config.textContent, textX + xOffset1, textY + yOffset1);
                const xOffset2 = (Math.random() - 0.5) * intensity; const yOffset2 = (Math.random() - 0.5) * intensity; ctx.fillStyle = config.glitchColor2; ctx.fillText(config.textContent, textX + xOffset2, textY + yOffset2);
            }
            ctx.fillStyle = config.textColor; ctx.fillText(config.textContent, textX, textY);
        }

        function runGlitches(level) {
            // Scanlines
            if (Math.random() < config.base.scanlineChance * level) {
                const intensity = config.base.scanlineIntensity * level;
                const y = Math.random() * height; const h = (Math.random() * 10) + 1; const xOffset = (Math.random() - 0.5) * intensity; ctx.drawImage(canvas, 0, y, width, h, xOffset, y, width, h);
            }
            // Block Scramble
            if (Math.random() < config.base.blockScrambleChance * level) {
                const count = Math.floor(config.base.blockScrambleCount * level);
                for (let i = 0; i < count; i++) {
                    const sx = Math.random() * width; const sy = Math.random() * height;
                    const sw = width * Math.random() * 0.2; const sh = height * Math.random() * 0.1;
                    const dx = Math.random() * width; const dy = Math.random() * height;
                    ctx.drawImage(canvas, sx, sy, sw, sh, dx, dy, sw, sh);
                }
            }
            // Vertical Jump
            if (Math.random() < config.base.vJumpChance * level) {
                const intensity = config.base.vJumpIntensity * level;
                const yOffset = (Math.random() - 0.5) * intensity;
                ctx.drawImage(canvas, 0, 0, width, height, 0, yOffset, width, height);
            }
            // Color Flash (capped at 3 flashes per second for accessibility)
            const flashChance = Math.min(config.base.colorFlashChance * level, config.base.maxFlashChance);
            if (Math.random() < flashChance) {
                ctx.fillStyle = config.base.flashColor; ctx.fillRect(0, 0, width, height);
            }
        }
        
        function animate() {
            ctx.fillStyle = `rgba(8, 8, 10, ${config.backgroundAlpha})`;
            ctx.fillRect(0, 0, width, height);

            const hasGlitch = glitchLevel > 0;

            dots.forEach(dot => {
                if (hasGlitch) { dot.glitch(glitchLevel); } else { dot.reset(); }
                dot.draw();
            });
            drawText(glitchLevel);
            
            if (hasGlitch) {
                runGlitches(glitchLevel);
            }
            
            requestAnimationFrame(animate);
        }

        // --- EVENT LISTENERS ---
        window.addEventListener('resize', setup);
        window.addEventListener('click', () => {
            glitchLevel = Math.min(glitchLevel + 1, maxGlitchLevel);
        });

        // --- START ---
        setup();
        animate();
    </script>
</body>
</html>